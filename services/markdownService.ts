import type { ContentBrief, CompetitorPage, OutlineItem } from '../types';

// Helper to generate slug for anchor links
const createSlug = (text: string) => {
  return text
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^\w-]+/g, '');
};

// Helper to get a clean domain link from a URL
const getDomainLink = (url: string): string => {
  try {
    const domain = new URL(url).hostname.replace('www.', '');
    return `[${domain}](${url})`;
  } catch (e) {
    return `[${url}](${url})`; // Fallback for invalid URLs
  }
};


// Recursive function to generate the article structure in Markdown
const generateOutlineMarkdown = (outline: OutlineItem[], level = 2, isConcise: boolean): string => {
  let markdown = '';
  outline.forEach(item => {
    const headingPrefix = '#'.repeat(level);
    
    let headingText = item.heading;
    if (item.level === 'Hero') {
        headingText = `H1: ${item.heading}`;
    } else if (item.level === 'Conclusion') {
        headingText = `H2: ${item.heading}`;
    } else if (item.level.startsWith('H')) {
        headingText = `${item.level}: ${item.heading}`;
    }
    
    // Create a unique anchor for each heading
    const anchor = ` {#${createSlug(headingText)}}`;

    markdown += `${headingPrefix} **${headingText}**${anchor}\n\n`;

    if (item.targeted_keywords && item.targeted_keywords.length > 0) {
      markdown += `*   **Targets:** \`${item.targeted_keywords.join('`, `')}\`\n`;
    }
    if (item.competitor_coverage && item.competitor_coverage.length > 0) {
      markdown += `*   **Covered By:** ${item.competitor_coverage.map(getDomainLink).join(', ')}\n`;
    }
    // Add a newline if we added targets or coverage to separate from guidelines/reasoning
    if ((item.targeted_keywords?.length > 0) || (item.competitor_coverage?.length > 0)) {
        markdown += `\n`;
    }

    if (!isConcise && item.reasoning) {
        markdown += `*   **Reasoning:** ${item.reasoning}\n`;
    }
    if (item.guidelines && item.guidelines.length > 0) {
      markdown += `*   **Guidelines:**\n${item.guidelines.map(g => `    *   ${g}`).join('\n')}\n\n`;
    } else {
        markdown += '\n';
    }

    if (item.additional_resources && item.additional_resources.length > 0) {
      markdown += `*   **ðŸš¨ Additional Resources Required:**\n`;
      markdown += item.additional_resources.map(r => `    *   ${r}`).join('\n') + '\n\n';
    }

    if (item.children && item.children.length > 0) {
      markdown += generateOutlineMarkdown(item.children, level + 1, isConcise);
    }
  });
  return markdown;
};

// Helper to generate the Table of Contents recursively
const generateToc = (outline: OutlineItem[], level = 0): string => {
    let toc = '';
    outline.forEach(item => {
        let headingText = item.heading;
        if (item.level === 'Hero') {
            headingText = `H1: ${item.heading}`;
        } else if (item.level === 'Conclusion') {
            headingText = `H2: ${item.heading}`;
        } else if (item.level.startsWith('H')) {
            headingText = `${item.level}: ${item.heading}`;
        }
        const slug = createSlug(headingText);
        const indent = '  '.repeat(level);
        toc += `${indent}- [${headingText}](#${slug})\n`;
        if (item.children && item.children.length > 0) {
            toc += generateToc(item.children, level + 1);
        }
    });
    return toc;
}

const getGroundTruthCompetitors = (competitorsList: CompetitorPage[]): CompetitorPage[] => {
    const starred = competitorsList.filter(c => c.is_starred);
    const notStarred = competitorsList.filter(c => !c.is_starred); // Assumes sorted by score
    const topCompetitors = [...starred];
    let i = 0;
    while(topCompetitors.length < 3 && i < notStarred.length) {
        if (!topCompetitors.some(c => c.URL === notStarred[i].URL)) {
            topCompetitors.push(notStarred[i]);
        }
        i++;
    }
    return topCompetitors.slice(0, 3);
};


export const exportBriefToMarkdown = (
  brief: Partial<ContentBrief>,
  competitors: CompetitorPage[],
  keywordMap: Map<string, number>,
  isConcise: boolean = false
) => {
  if (!brief || Object.keys(brief).length === 0) {
    console.error("Brief data is empty. Cannot export.");
    return;
  }
  
  const { page_goal, target_audience, keyword_strategy, competitor_insights, content_gap_analysis, on_page_seo, article_structure, faqs } = brief;
  
  const mainKeyword = keyword_strategy?.primary_keywords?.[0]?.keyword || "Untitled Article";

  const competitorLinks = competitors
    .filter(c => c.is_starred)
    .map((c, i) => `* [Starred Competitor ${i + 1}](${c.URL})`)
    .join('\n');

  // --- BUILD MARKDOWN STRING ---
  
  // Header
  let markdownContent = `# **${mainKeyword} - Content Brief** {#article-name}\n\n`;
  markdownContent += `+ Generated by: BriefStrategist, Last edited: ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}\n\n`;
  
  if (competitorLinks) {
      markdownContent += `#### **Relevant Links:**\n\n${competitorLinks}\n\n`;
  }
  
  // Table of Contents
  markdownContent += `## *Table of Contents*\n\n`;
  markdownContent += `[Strategy and Goals](#strategy-and-goals)\n`;
  markdownContent += `[Page Goal](#page-goal)\n`;
  markdownContent += `[Target Audience](#target-audience)\n`;
  markdownContent += `[Keyword Strategy](#keyword-strategy)\n`;
  if (competitor_insights) {
    markdownContent += `[Competitive Analysis](#competitive-analysis)\n`;
  }
  if (content_gap_analysis) {
    markdownContent += `[Content Gap Analysis](#content-gap-analysis)\n`;
  }
  markdownContent += `[On Page SEO](#on-page-seo)\n`;
  markdownContent += `[Article Structure](#article-structure)\n`;
  if (article_structure?.outline) {
      markdownContent += generateToc(article_structure.outline, 1);
  }
  if (faqs?.questions?.length) {
      markdownContent += `[Frequently Asked Questions](#frequently-asked-questions)\n`;
  }
  markdownContent += `\n`;

  // Strategy and Goals
  markdownContent += `## Strategy and Goals {#strategy-and-goals}\n\n`;
  markdownContent += `### Page Goal {#page-goal}\n\n`;
  markdownContent += `**Goal:** ${page_goal?.value || 'Not defined.'}\n`;
  if (!isConcise) markdownContent += `> **Reasoning:** *${page_goal?.reasoning || 'Not defined.'}*\n\n`; else markdownContent += `\n`;
  
  markdownContent += `### Target Audience {#target-audience}\n\n`;
  markdownContent += `**Audience:** ${target_audience?.value || 'Not defined.'}\n`;
  if (!isConcise) markdownContent += `> **Reasoning:** *${target_audience?.reasoning || 'Not defined.'}*\n\n`; else markdownContent += `\n`;

  // Keyword Strategy
  markdownContent += `## Keyword Strategy {#keyword-strategy}\n\n`;
  if (keyword_strategy) {
    if (!isConcise) markdownContent += `> **Strategy Rationale:** *${keyword_strategy.reasoning}*\n\n`;
    markdownContent += `| Type | Keyword | Monthly Searches | Intent / Notes |\n`;
    markdownContent += `| :---: | ----- | :---: | :---: |\n`;
    
    keyword_strategy.primary_keywords.forEach(kw => {
        const volume = keywordMap.get(kw.keyword.toLowerCase())?.toLocaleString() || 'N/A';
        markdownContent += `| **Primary** | ${kw.keyword} | ${volume} | ${kw.notes} |\n`;
    });

    keyword_strategy.secondary_keywords.forEach(kw => {
        const volume = keywordMap.get(kw.keyword.toLowerCase())?.toLocaleString() || 'N/A';
        markdownContent += `| Secondary | ${kw.keyword} | ${volume} | ${kw.notes} |\n`;
    });
    markdownContent += `\n`;
  }
  
  // Competitive Analysis
  if (competitor_insights) {
    markdownContent += `## Competitive Analysis {#competitive-analysis}\n\n`;
    markdownContent += `### Differentiation Summary\n\n`;
    markdownContent += `${competitor_insights.differentiation_summary.value}\n\n`;
    
    const top3Competitors = getGroundTruthCompetitors(competitors);
    if (top3Competitors.length > 0) {
        markdownContent += `### Top 3 Competitors Analyzed\n\n`;
        top3Competitors.forEach(comp => {
            markdownContent += `* ${getDomainLink(comp.URL)}\n`;
        });
        markdownContent += `\n`;
    }
  }

  // Content Gap Analysis
  if (content_gap_analysis) {
    markdownContent += `## Content Gap Analysis {#content-gap-analysis}\n\n`;
    if (!isConcise) markdownContent += `> **Strategy Rationale:** *${content_gap_analysis.reasoning}*\n\n`;

    markdownContent += `### Table Stakes (Must-Have Topics)\n\n`;
    content_gap_analysis.table_stakes.forEach(item => {
        markdownContent += `*   **Topic:** ${item.value}\n`;
        if (!isConcise) markdownContent += `    *   **Reasoning:** ${item.reasoning}\n`;
    });
    markdownContent += `\n`;

    markdownContent += `### Strategic Opportunities (Content Gaps)\n\n`;
    content_gap_analysis.strategic_opportunities.forEach(item => {
        markdownContent += `*   **Opportunity:** ${item.value}\n`;
        if (!isConcise) markdownContent += `    *   **Reasoning:** ${item.reasoning}\n`;
    });
    markdownContent += `\n`;
  }

  // On-Page SEO
  markdownContent += `## On Page SEO {#on-page-seo}\n\n`;
  if (on_page_seo) {
    if (isConcise) {
        markdownContent += `| Element | Recommendation |\n`;
        markdownContent += `| :---- | :---- |\n`;
        markdownContent += `| **Meta Title** | ${on_page_seo.title_tag.value} |\n`;
        markdownContent += `| **Meta Description** | ${on_page_seo.meta_description.value} |\n`;
        markdownContent += `| **URL slug** | ${on_page_seo.url_slug.value} |\n`;
        markdownContent += `| **H1** | ${on_page_seo.h1.value} |\n`;
        if (on_page_seo.og_title) markdownContent += `| **OG Title** | ${on_page_seo.og_title.value} |\n`;
        if (on_page_seo.og_description) markdownContent += `| **OG Description** | ${on_page_seo.og_description.value} |\n`;
    } else {
        markdownContent += `| Element | Recommendation | Reasoning |\n`;
        markdownContent += `| :---- | :---- | :---- |\n`;
        markdownContent += `| **Meta Title** | ${on_page_seo.title_tag.value} | ${on_page_seo.title_tag.reasoning} |\n`;
        markdownContent += `| **Meta Description** | ${on_page_seo.meta_description.value} | ${on_page_seo.meta_description.reasoning} |\n`;
        markdownContent += `| **URL slug** | ${on_page_seo.url_slug.value} | ${on_page_seo.url_slug.reasoning} |\n`;
        markdownContent += `| **H1** | ${on_page_seo.h1.value} | ${on_page_seo.h1.reasoning} |\n`;
        if (on_page_seo.og_title) markdownContent += `| **OG Title** | ${on_page_seo.og_title.value} | ${on_page_seo.og_title.reasoning} |\n`;
        if (on_page_seo.og_description) markdownContent += `| **OG Description** | ${on_page_seo.og_description.value} | ${on_page_seo.og_description.reasoning} |\n`;
    }
    markdownContent += `\n`;
  }

  // Article Structure
  markdownContent += `## Article Structure {#article-structure}\n\n`;
  if (article_structure) {
    markdownContent += `**Recommended Word Count:** ${article_structure.word_count_target.toLocaleString()}\n`;
    if (!isConcise) markdownContent += `> **Reasoning:** *${article_structure.reasoning}*\n\n`; else markdownContent += `\n`;
    markdownContent += generateOutlineMarkdown(article_structure.outline, 2, isConcise);
  }
  
  // FAQs Section
  if (faqs && faqs.questions && faqs.questions.length > 0) {
      markdownContent += `## **H2: Frequently Asked Questions** {#frequently-asked-questions}\n\n`;
      if (!isConcise && faqs.reasoning) {
          markdownContent += `> **Reasoning:** *${faqs.reasoning}*\n\n`;
      }
      faqs.questions.forEach(faq => {
          markdownContent += `### **H3: ${faq.question}**\n\n`;
          if (faq.guidelines && faq.guidelines.length > 0) {
            markdownContent += `*   **Guidelines:**\n${faq.guidelines.map(g => `    *   ${g}`).join('\n')}\n\n`;
          }
      });
  }

  // --- TRIGGER DOWNLOAD ---
  const blob = new Blob([markdownContent], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${createSlug(mainKeyword)}-brief${isConcise ? '-concise' : ''}.md`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};


export const exportArticleToMarkdown = (article: { title: string, content: string }) => {
    if (!article || !article.content) {
        console.error("Article data is empty. Cannot export.");
        return;
    }

    const blob = new Blob([article.content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${createSlug(article.title || 'untitled-article')}.md`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}


/**
 * Applies inline markdown formatting (bold, italic) to a text string.
 */
function applyInlineFormatting(text: string): string {
  text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  text = text.replace(/\*(.+?)\*/g, '<em>$1</em>');
  return text;
}

/**
 * Converts article markdown to rich HTML and copies it to the clipboard.
 * When pasted into Google Docs, headings, bold, italic, lists, and
 * paragraph formatting are preserved.
 */
export async function copyArticleToClipboardRich(content: string): Promise<void> {
  if (!content) {
    throw new Error('No content to copy.');
  }

  const lines = content.split('\n');
  const htmlParts: string[] = [];
  let i = 0;

  while (i < lines.length) {
    const line = lines[i];

    if (line.trim() === '') {
      i++;
      continue;
    }

    const h3Match = line.match(/^###\s+(.*)/);
    if (h3Match) {
      htmlParts.push(`<h3>${applyInlineFormatting(h3Match[1].trim())}</h3>`);
      i++;
      continue;
    }

    const h2Match = line.match(/^##\s+(.*)/);
    if (h2Match) {
      htmlParts.push(`<h2>${applyInlineFormatting(h2Match[1].trim())}</h2>`);
      i++;
      continue;
    }

    const h1Match = line.match(/^#\s+(.*)/);
    if (h1Match) {
      htmlParts.push(`<h1>${applyInlineFormatting(h1Match[1].trim())}</h1>`);
      i++;
      continue;
    }

    if (line.match(/^[-*]\s+/)) {
      const items: string[] = [];
      while (i < lines.length && lines[i].match(/^[-*]\s+/)) {
        const itemText = lines[i].replace(/^[-*]\s+/, '');
        items.push(`<li>${applyInlineFormatting(itemText.trim())}</li>`);
        i++;
      }
      htmlParts.push(`<ul>${items.join('')}</ul>`);
      continue;
    }

    if (line.match(/^\d+\.\s+/)) {
      const items: string[] = [];
      while (i < lines.length && lines[i].match(/^\d+\.\s+/)) {
        const itemText = lines[i].replace(/^\d+\.\s+/, '');
        items.push(`<li>${applyInlineFormatting(itemText.trim())}</li>`);
        i++;
      }
      htmlParts.push(`<ol>${items.join('')}</ol>`);
      continue;
    }

    htmlParts.push(`<p>${applyInlineFormatting(line.trim())}</p>`);
    i++;
  }

  const html = htmlParts.join('');

  const htmlBlob = new Blob([html], { type: 'text/html' });
  const textBlob = new Blob([content], { type: 'text/plain' });
  const clipboardItem = new ClipboardItem({
    'text/html': htmlBlob,
    'text/plain': textBlob,
  });
  await navigator.clipboard.write([clipboardItem]);
}